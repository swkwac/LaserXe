
LESION SPOT PLANNER (Notepad / single-file reference)
=====================================================

Purpose
-------
Given:
  1) a photo of a lesion (clean image) and
  2) a photo of the same lesion with painted masks (blue/white/green),
this script:
  - extracts the masks
  - scales pixels to mm using a known real-world lesion width (e.g., 20 mm)
  - generates a set of treatment spot coordinates (x_mm, y_mm)
    aligned to fixed angular sweep lines (Δθ, e.g., 5°)
  - avoids spot overlap
  - supports multiple disconnected mask components (islands)
    and discards components smaller than 1% of that color's total mask area
  - exports a motion CSV (ordered execution)
  - renders:
      * a readable engineering chart (mask outlines + spots + θ axes)
      * a 5s GIF animation (clean photo) of the head moving and flashing

Notes
-----
- Coordinate convention (IMPORTANT):
    * mm space: +x right, +y up, origin at image center
    * pixel space: +x right, +y down
    * mapping:
         x_px = cx + x_mm * px_per_mm
         y_px = cy - y_mm * px_per_mm

- Rotation direction:
    This file uses a "CLOCKWISE" convention for the plotted / motion geometry:
        angle_rad = +radians(theta_deg)
    If your device convention differs, flip the sign in axis_angle_plot().

Requirements
------------
Python 3.10+ recommended.
Packages:
  pip install numpy pandas pillow matplotlib

Usage
-----
Edit the CONFIG section paths and desired coverage percentages, then run:
  python lesion_spot_planner.py

Outputs (written next to the script by default):
  - motion CSV (ordered):  <prefix>_motion.csv
  - chart PNG:            <prefix>_chart.png
  - clean GIF:            <prefix>_clean.gif
  - mask GIF (optional):  <prefix>_masks.gif


--------------------------------------------------------------------------------

lesion_spot_planner.py (copy/paste)


# ============================
# lesion_spot_planner.py
# ============================
import math
from pathlib import Path
from collections import deque

import numpy as np
import pandas as pd
from PIL import Image
import matplotlib.pyplot as plt


# =======================
# CONFIG (EDIT THIS)
# =======================

CLEAN_IMG_PATH = "zmiana skorna 8.png"
MASK_IMG_PATH  = "zmiana skorna 8 z 3 maskami.png"

# Real-world scaling: union of all masks spans this width in mm
LESION_UNION_WIDTH_MM = 20.0

# Treatment aperture and spot parameters
TREATMENT_CIRCLE_DIAM_MM = 25.0
SPOT_DIAM_MM = 0.3

# Angular sweep constraint (fixed step)
DTHETA_DEG = 5.0

# Candidate sampling along each line (smaller = more candidates, slower)
CANDIDATE_STEP_MM = 0.2

# Discard connected components smaller than this fraction of that color’s total area
DISCARD_COMPONENTS_BELOW_FRAC = 0.01

# Desired coverage per mask color: (spot_area_sum / mask_area) ≈ target
TARGET_COVERAGE = {
    "blue":  0.20,
    "white": 0.10,
    "green": 0.05,
}

# Output prefix
OUT_PREFIX = "lesion_plan"


# =======================
# MASK THRESHOLDS (EDIT if your colors differ)
# =======================
def extract_raw_masks(rgb01: np.ndarray) -> dict[str, np.ndarray]:
    """Return boolean masks for blue/white/green from the mask-painted image."""
    R, G, B = rgb01[..., 0], rgb01[..., 1], rgb01[..., 2]
    mask_white = (R > 0.92) & (G > 0.92) & (B > 0.92)
    mask_green = (G > 0.55) & (R < 0.40) & (B < 0.40)
    mask_blue  = (B > 0.55) & (G > 0.40) & (R < 0.45)
    return {"blue": mask_blue, "white": mask_white, "green": mask_green}


# =======================
# CONNECTED COMPONENTS
# =======================
def connected_components(binary: np.ndarray, min_px: int = 200) -> list[list[tuple[int,int]]]:
    """8-connected components. Returns list of pixel coordinate lists (y,x)."""
    H, W = binary.shape
    visited = np.zeros_like(binary, bool)
    comps: list[list[tuple[int,int]]] = []
    for y in range(H):
        for x in range(W):
            if binary[y, x] and not visited[y, x]:
                q = deque([(y, x)])
                visited[y, x] = True
                pix: list[tuple[int,int]] = []
                while q:
                    cy, cx = q.popleft()
                    pix.append((cy, cx))
                    for dy in (-1, 0, 1):
                        for dx in (-1, 0, 1):
                            if dy == 0 and dx == 0:
                                continue
                            ny, nx = cy + dy, cx + dx
                            if 0 <= ny < H and 0 <= nx < W and binary[ny, nx] and not visited[ny, nx]:
                                visited[ny, nx] = True
                                q.append((ny, nx))
                if len(pix) >= min_px:
                    comps.append(pix)
    comps.sort(key=len, reverse=True)
    return comps


def pix_to_mask(pix: list[tuple[int,int]], shape: tuple[int,int]) -> np.ndarray:
    m = np.zeros(shape, bool)
    for y, x in pix:
        m[y, x] = True
    return m


# =======================
# PLANNER CORE
# =======================
def axis_angle_plot(theta_deg: float) -> float:
    """
    CLOCKWISE convention:
      increasing theta_deg rotates clockwise in our plotted/motion frame.
    If you see counter-clockwise behavior, flip the sign here.
    """
    return math.radians(theta_deg)  # clockwise


def build_candidate_lines(mask: np.ndarray,
                          inside_fn,
                          R_mm: float,
                          dtheta_deg: float,
                          candidate_step_mm: float) -> list[tuple[int,float,list[tuple[float,float,float]]]]:
    thetas = np.arange(0.0, math.pi, math.radians(dtheta_deg), dtype=float)
    lines = []
    for k, th in enumerate(thetas):
        ct, st = math.cos(th), math.sin(th)
        ts = np.arange(-R_mm, R_mm + 1e-9, candidate_step_mm)
        if k % 2 == 1:
            ts = ts[::-1]
        cand = []
        for t in ts:
            x = t * ct
            y = t * st  # +y up in mm
            if x*x + y*y > R_mm*R_mm:
                continue
            if inside_fn(x, y, mask):
                cand.append((t, x, y))
        lines.append((k, k * dtheta_deg, cand))
    return lines


def select_points(lines, min_dist_mm: float, avoid_xy: list[tuple[float,float]]) -> list[tuple[float,float,float,float]]:
    min2 = min_dist_mm * min_dist_mm
    selected: list[tuple[float,float,float,float]] = []
    for _, th_deg, cand in lines:
        last_t = None
        for t, x, y in cand:
            if last_t is not None and abs(t - last_t) < min_dist_mm:
                continue
            if any((x-ax)**2 + (y-ay)**2 < min2 for ax, ay in avoid_xy):
                continue
            if any((x-sx)**2 + (y-sy)**2 < min2 for _, _, sx, sy in selected):
                continue
            selected.append((th_deg, t, x, y))
            last_t = t
    return selected


def tune_min_dist(lines, target_n: int, avoid_xy: list[tuple[float,float]], spot_d_mm: float) -> list[tuple[float,float,float,float]]:
    lo, hi = spot_d_mm, 5.0
    best: list[tuple[float,float,float,float]] = []
    for _ in range(18):
        mid = (lo + hi) / 2
        sel = select_points(lines, mid, avoid_xy)
        if not best or abs(len(sel) - target_n) < abs(len(best) - target_n):
            best = sel
        if len(sel) > target_n:
            lo = mid
        else:
            hi = mid
    return best


def allocate_targets_per_component(areas_px: list[int], total_target: int) -> list[int]:
    n = len(areas_px)
    if n == 0:
        return []
    if total_target <= 0:
        return [0] * n
    areas = np.array(areas_px, float)
    weights = areas / areas.sum()
    raw = weights * total_target
    alloc = np.floor(raw).astype(int)
    if total_target >= n:
        alloc = np.maximum(alloc, 1)
    diff = int(total_target - alloc.sum())
    frac = raw - np.floor(raw)
    order = np.argsort(-frac)
    i = 0
    while diff > 0:
        alloc[order[i % n]] += 1
        diff -= 1
        i += 1
    over = int(alloc.sum() - total_target)
    if over > 0:
        order2 = np.argsort(frac)
        j = 0
        while over > 0:
            idx = order2[j % n]
            if total_target >= n:
                if alloc[idx] > 1:
                    alloc[idx] -= 1
                    over -= 1
            else:
                if alloc[idx] > 0:
                    alloc[idx] -= 1
                    over -= 1
            j += 1
    return alloc.tolist()


def boundary(binary: np.ndarray) -> np.ndarray:
    b = np.zeros_like(binary, bool)
    H, W = binary.shape
    for y in range(1, H - 1):
        for x in range(1, W - 1):
            if binary[y, x] and not binary[y-1:y+2, x-1:x+2].all():
                b[y, x] = True
    return b


def render_readable_chart(out_png: Path,
                          df: pd.DataFrame,
                          masks: dict[str,np.ndarray],
                          px_per_mm: float,
                          cx: float, cy: float,
                          R_mm: float,
                          dtheta_deg: float,
                          spot_d_mm: float,
                          title: str):
    spot_area = math.pi * (spot_d_mm / 2) ** 2

    def px_to_mm(xp, yp):
        return (xp - cx) / px_per_mm, (cy - yp) / px_per_mm

    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_aspect("equal")
    ax.grid(True, linestyle="--", alpha=0.35)
    ax.add_patch(plt.Circle((0, 0), R_mm, fill=False, lw=3, color="black"))

    for th in np.arange(0, 180, dtheta_deg):
        a = axis_angle_plot(th)
        ax.plot([-R_mm * math.cos(a), R_mm * math.cos(a)],
                [-R_mm * math.sin(a), R_mm * math.sin(a)],
                ":", alpha=0.15)

    for cname, col in [("blue", "blue"), ("white", "black"), ("green", "green")]:
        b = boundary(masks[cname])
        by, bx = np.where(b)
        xm, ym = px_to_mm(bx, by)
        ax.scatter(xm, ym, s=4, color=col, alpha=0.8, label=f"{cname} mask")

    for cname, col in [("blue", "blue"), ("white", "orange"), ("green", "green")]:
        d = df[df["mask"] == cname]
        mask_area_mm2 = masks[cname].sum() / (px_per_mm ** 2)
        achieved = (len(d) * spot_area / mask_area_mm2) * 100 if mask_area_mm2 > 0 else 0
        ax.scatter(d["x_mm"], d["y_mm"], s=70, edgecolor="black", color=col,
                   label=f"{cname} spots ({achieved:.1f}%)")

    ax.set_xlabel("x [mm]")
    ax.set_ylabel("y [mm]")
    ax.set_xlim(-R_mm - 2, R_mm + 2)
    ax.set_ylim(-R_mm - 2, R_mm + 2)
    ax.set_title(title)
    ax.legend(loc="upper right", fontsize=9)
    plt.tight_layout()
    fig.savefig(out_png, dpi=200)
    plt.close(fig)


def render_fluent_gif(out_gif: Path,
                      rgb_bg: np.ndarray,
                      extent: list[float],
                      df: pd.DataFrame,
                      R_mm: float,
                      dtheta_deg: float,
                      duration_s: float = 5.0,
                      fps: int = 12):
    theta_arr = df["theta_deg"].to_numpy()
    t_arr = df["t_mm"].to_numpy()
    x_all = df["x_mm"].to_numpy()
    y_all = df["y_mm"].to_numpy()

    def xy_from_t_theta(t, th_deg):
        a = axis_angle_plot(th_deg)
        return t * math.cos(a), t * math.sin(a)

    events = []
    for i in range(len(df)):
        th, t = theta_arr[i], t_arr[i]
        events.append(("emit", th, t, i))
        if i < len(df) - 1:
            th2, t2 = theta_arr[i + 1], t_arr[i + 1]
            if th2 == th:
                events.append(("move", th, t, t2))
            else:
                events.append(("rotate", t, th, th2))

    head = []
    fired = []
    axis = []
    flash = []
    fired_idx = []
    for e in events:
        if e[0] == "emit":
            _, th, t, i = e
            fired_idx.append(i)
            for k in range(4):
                head.append(xy_from_t_theta(t, th))
                fired.append(fired_idx.copy())
                axis.append(axis_angle_plot(th))
                flash.append(k >= 2)
        elif e[0] == "move":
            _, th, t0, t1 = e
            dist = abs(t1 - t0)
            n = max(3, int(round(dist * 3)))
            for u in np.linspace(0, 1, n):
                head.append(xy_from_t_theta((1 - u) * t0 + u * t1, th))
                fired.append(fired_idx.copy())
                axis.append(axis_angle_plot(th))
                flash.append(False)
        else:
            _, t, th0, th1 = e
            for u in np.linspace(0, 1, 6):
                th = (1 - u) * th0 + u * th1
                head.append(xy_from_t_theta(t, th))
                fired.append(fired_idx.copy())
                axis.append(axis_angle_plot(th))
                flash.append(False)

    frames = int(duration_s * fps)
    idx_map = np.linspace(0, len(head) - 1, frames).astype(int)

    fig, ax = plt.subplots(figsize=(6.8, 6.8))
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlabel("x [mm]")
    ax.set_ylabel("y [mm]")
    ax.grid(True, linestyle="--", alpha=0.30)
    ax.add_patch(plt.Circle((0, 0), R_mm, fill=False, lw=2))
    ax.imshow(rgb_bg, extent=extent, origin="upper")

    for th in np.arange(0, 180, dtheta_deg):
        a = axis_angle_plot(th)
        ax.plot([-R_mm * math.cos(a), R_mm * math.cos(a)],
                [-R_mm * math.sin(a), R_mm * math.sin(a)],
                ":", alpha=0.16, lw=0.8)

    sc = ax.scatter([], [], s=26)
    hd = ax.scatter([], [], s=90, color="red")
    axl, = ax.plot([], [], lw=3.0, alpha=0.6)

    margin = 2
    ax.set_xlim(-R_mm - margin, R_mm + margin)
    ax.set_ylim(-R_mm - margin, R_mm + margin)
    fig.tight_layout()

    frames_pil = []
    from PIL import Image as PILImage
    for k in range(frames):
        i = idx_map[k]
        fi = fired[i]
        if fi:
            sc.set_offsets(np.c_[x_all[fi], y_all[fi]])
        else:
            sc.set_offsets(np.empty((0, 2)))
        hd.set_offsets(np.array([head[i]]))
        hd.set_sizes([160 if flash[i] else 90])
        hd.set_alpha(1.0 if flash[i] else 0.9)
        a = axis[i]
        axl.set_data([-R_mm * math.cos(a), R_mm * math.cos(a)],
                     [-R_mm * math.sin(a), R_mm * math.sin(a)])
        fig.canvas.draw()
        ww, hh = fig.canvas.get_width_height()
        buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8).reshape(hh, ww, 3)
        frames_pil.append(PILImage.fromarray(buf))

    plt.close(fig)
    frames_pil[0].save(out_gif, save_all=True, append_images=frames_pil[1:],
                       duration=int(1000 / fps), loop=0, optimize=False)


def main():
    clean_img = Image.open(CLEAN_IMG_PATH).convert("RGB")
    mask_img = Image.open(MASK_IMG_PATH).convert("RGB")
    if clean_img.size != mask_img.size:
        clean_img = clean_img.resize(mask_img.size, Image.BILINEAR)

    rgb_clean = np.asarray(clean_img).astype(np.float32) / 255.0
    rgb_mask = np.asarray(mask_img).astype(np.float32) / 255.0
    h, w = rgb_mask.shape[:2]
    cx, cy = w / 2, h / 2

    raw_masks = extract_raw_masks(rgb_mask)

    comp_masks = {}
    for color, raw in raw_masks.items():
        comps = connected_components(raw, min_px=200)
        comp_masks[color] = [pix_to_mask(pix, (h, w)) for pix in comps]

    union = np.zeros((h, w), bool)
    for ms in comp_masks.values():
        for m in ms:
            union |= m
    ys, xs = np.where(union)
    if len(xs) == 0:
        raise RuntimeError("No mask pixels detected. Check thresholds.")
    bbox = (xs.min(), ys.min(), xs.max(), ys.max())
    px_per_mm = (bbox[2] - bbox[0] + 1) / LESION_UNION_WIDTH_MM

    R_mm = TREATMENT_CIRCLE_DIAM_MM / 2
    yy, xx = np.mgrid[0:h, 0:w]
    circle = ((xx - cx) ** 2 + (yy - cy) ** 2) <= (R_mm * px_per_mm) ** 2

    final_components = {}
    for color, ms in comp_masks.items():
        ms2 = [m & circle for m in ms if (m & circle).sum() > 0]
        if not ms2:
            final_components[color] = []
            continue
        areas = np.array([m.sum() for m in ms2], float)
        total = areas.sum()
        keep = areas >= (DISCARD_COMPONENTS_BELOW_FRAC * total)
        final_components[color] = [m for m, k in zip(ms2, keep) if k]

    def mm_to_px(x_mm, y_mm):
        return cx + x_mm * px_per_mm, cy - y_mm * px_per_mm

    def inside_mm(x_mm, y_mm, mask):
        x_px, y_px = mm_to_px(x_mm, y_mm)
        xi, yi = int(round(x_px)), int(round(y_px))
        return (0 <= xi < w and 0 <= yi < h and mask[yi, xi])

    spot_area = math.pi * (SPOT_DIAM_MM / 2) ** 2
    rows = []
    avoid_xy = []

    for color in ["blue", "white", "green"]:
        comps = final_components[color]
        if not comps:
            continue
        total_area_px = sum(m.sum() for m in comps)
        total_area_mm2 = total_area_px / (px_per_mm ** 2)
        total_target = int(round(TARGET_COVERAGE[color] * total_area_mm2 / spot_area))
        if total_target <= 0:
            continue
        alloc = allocate_targets_per_component([int(m.sum()) for m in comps], total_target)

        for comp_id, (mask_comp, n_target) in enumerate(zip(comps, alloc), start=1):
            if n_target <= 0:
                continue
            lines = build_candidate_lines(mask_comp, inside_mm, R_mm, DTHETA_DEG, CANDIDATE_STEP_MM)
            sel = tune_min_dist(lines, n_target, avoid_xy, SPOT_DIAM_MM)
            for th_deg, t_mm, x_mm, y_mm in sel:
                rows.append((color, comp_id, th_deg, t_mm, x_mm, y_mm))
            avoid_xy.extend([(x_mm, y_mm) for _, _, x_mm, y_mm in sel])

    df = pd.DataFrame(rows, columns=["mask", "component_id", "theta_deg", "t_mm", "x_mm", "y_mm"])

    theta_vals = np.sort(df["theta_deg"].unique())
    theta_to_k = {th: i for i, th in enumerate(theta_vals)}
    df["theta_k"] = df["theta_deg"].map(theta_to_k)
    df["t_sort"] = df["t_mm"]
    df.loc[df["theta_k"] % 2 == 1, "t_sort"] *= -1
    df = df.sort_values(["theta_k", "t_sort"]).reset_index(drop=True)
    df.insert(0, "index", np.arange(len(df)))
    df = df.drop(columns=["t_sort"])

    out_dir = Path(".")
    csv_path = out_dir / f"{OUT_PREFIX}_motion.csv"
    chart_path = out_dir / f"{OUT_PREFIX}_chart.png"
    gif_clean = out_dir / f"{OUT_PREFIX}_clean.gif"

    df.to_csv(csv_path, index=False)
    print(f"Saved CSV: {csv_path} (spots={len(df)})")

    final_union_masks = {}
    for color in ["blue", "white", "green"]:
        m = np.zeros((h, w), bool)
        for c in final_components.get(color, []):
            m |= c
        final_union_masks[color] = m

    render_readable_chart(
        chart_path, df, final_union_masks, px_per_mm, cx, cy,
        R_mm, DTHETA_DEG, SPOT_DIAM_MM,
        title=f"{OUT_PREFIX} | Δθ={DTHETA_DEG}° | multi-mask plan"
    )
    print(f"Saved chart: {chart_path}")

    extent = [
        (0 - cx) / px_per_mm,
        (w - cx) / px_per_mm,
        (cy - h) / px_per_mm,
        (cy - 0) / px_per_mm,
    ]

    bg = np.dstack([rgb_clean, np.full((h, w), 0.85, dtype=np.float32)])
    render_fluent_gif(gif_clean, bg, extent, df, R_mm, DTHETA_DEG, duration_s=5.0, fps=12)
    print(f"Saved GIF: {gif_clean}")

    # Safety check: every point must land in its own mask union
    bad = 0
    for _, r in df.iterrows():
        col = r["mask"]
        x_px, y_px = mm_to_px(r["x_mm"], r["y_mm"])
        xi, yi = int(round(x_px)), int(round(y_px))
        if not (0 <= xi < w and 0 <= yi < h and final_union_masks[col][yi, xi]):
            bad += 1
    if bad:
        print(f"WARNING: {bad} spots outside intended masks.")
    else:
        print("All spots verified inside intended masks.")


if __name__ == "__main__":
    main()
